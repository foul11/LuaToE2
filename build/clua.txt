@name CLua

ALWAYS_TRUE = 1
if(first()){
    function table table:cluaNewVar(Type){
        if(!(This["_class",number] == 1)){
            error("cluaNewVar" + " " + "can't use to" + " " + "_CLUA_TYPE_INSTANCE" + "[got " + This["_class",number] + "]" + ":" + 142)
        }
        
        switch(Type){
            case 1,
            case 2,
            case 3,
            case 4,
            case 5,
            case 6,
            case 7,
            case 8,
                return table("Type" = Type, "_class" = 2)
            default,
                error("cluaNewVar var type not found: " + Type)
        }
    }
    
    function table table:cluaGetVar(Name:string){
        if(!(This["_class",number] == 5)){
            error("cluaGetVar" + " " + "can't get var from:" + " " + "_CLUA_TYPE_CONTEXT" + "[got " + This["_class",number] + "]" + ":" + 164)
        }
        
        if(ALWAYS_TRUE){
            local Scopes = This["Scopes",table]
            local Count = Scopes:ncount()
            
            for(I=Count, 1, -1){
                local SVars = Scopes[I,table]["Vars",table]
                
                if(SVars:exists(Name)){
                    return SVars[Name,table]
                }
            }
        }
        
        if(ALWAYS_TRUE){
            local Instance = This["Instance",table]
            local GVars = Instance["Vars",table]
            
            if(GVars:exists(Name)){
                return GVars[Name,table]
            }
            
            if(ALWAYS_TRUE){
                return Instance:cluaNewVar(8)
            }
        }
    }
    
    function table table:cluaMakeExtFunc(Name:string){
        if(!(This["_class",number] == 1)){
            error("cluaMakeExtFunc" + " " + "can't use to" + " " + "_CLUA_TYPE_INSTANCE" + "[got " + This["_class",number] + "]" + ":" + 194)
        }
        local ExtFunc = This:cluaNewVar(2)
        ExtFunc["Value",table] = table("Code" = table("_Type" = 10, 1 = table("_Type" = 1, 1 = "clua_" + Name)), "Instance" = This, "Args" = table(), "_class" = 4)
        return ExtFunc
    }
    
    function table table:cluaBuildEnv(Vars:table){
        if(!(This["_class",number] == 1)){
            error("cluaBuildEnv" + " " + "can't use to" + " " + "_CLUA_TYPE_INSTANCE" + "[got " + This["_class",number] + "]" + ":" + 215)
        }
        
        if(!(Vars["_class",number] == 2)){
            error("cluaBuildEnv" + " " + "accept only table variables" + " " + "_CLUA_TYPE_VARIABLE" + "[got " + Vars["_class",number] + "]" + ":" + 216)
        }
        This["Vars",table] = This["Vars",table]:merge(Vars)
        return This
    }
    
    function table table:cluaBuildEnv(){
        if(!(This["_class",number] == 1)){
            error("cluaBuildEnv" + " " + "can't use to" + " " + "_CLUA_TYPE_INSTANCE" + "[got " + This["_class",number] + "]" + ":" + 224)
        }
        This["Vars",table] = table("PrintTable" = This:cluaMakeExtFunc("printTable"), "print" = This:cluaMakeExtFunc("print"))
        return This
    }
    
    function table cluaInstance(){
        local Version = 5.1
        return table("Vars" = table(), "Version" = Version, "_class" = 1):cluaBuildEnv()
    }
    
    function table table:cluaToFunc(Code:table){
        if(!(This["_class",number] == 1)){
            error("cluaToFunc" + " " + "not compile to function (This):" + " " + "_CLUA_TYPE_INSTANCE" + "[got " + This["_class",number] + "]" + ":" + 245)
        }
        
        if(!(Code["_Type",number] == 10)){
            error("cluaToFunc" + " " + "not compile to function (Code)" + ":" + 246)
        }
        return table("Code" = Code, "Instance" = This, "Args" = table(), "_class" = 3)
    }
    
    function table table:cluaSCOPEpush(Code:table, IndexReturn){
        if(!(This["_class",number] == 9)){
            error("cluaSCOPEpush" + " " + "can't use to:" + " " + "_CLUA_TYPE_SCOPES" + "[got " + This["_class",number] + "]" + ":" + 267)
        }
        
        if(!Code["_Type",number]){
            error("cluaSCOPEpush" + " " + "Statment type is null" + ":" + 268)
        }
        This:pushTable(table("Code" = Code, "Vars" = table(), "Scopes" = table("_class" = 9, "_classsub" = 10), "Contexts" = table("_class" = 6, "_classsub" = 7), "Return" = table(), "Instruction" = 1, "CurrVar" = table(), "IndexReturn" = IndexReturn, "_class" = 8))
        return This
    }
    
    function table table:cluaSCOPEpop(){
        if(!(This["_class",number] == 9)){
            error("cluaSCOPEpop" + " " + "can't use to:" + " " + "_CLUA_TYPE_SCOPES" + "[got " + This["_class",number] + "]" + ":" + 292)
        }
        
        if(!This:ncount()){
            error("cluaSCOPEpop" + " " + "Scopes count is 0" + ":" + 293)
        }
        return This:popTable()
    }
    
    function table table:cluaCreateFuncContext(){
        if(!(This["_class",number] == 3 | This["_class",number] == 4)){
            error("cluaCreateFuncContext" + " " + "can't create context" + ":" + 299)
        }
        local Ctx = table("Scopes" = table("_class" = 9):cluaSCOPEpush(This["Code",table], 1), "Instance" = This["Instance",table], "Func" = This, "IsComplete" = 0, "VarArg" = table(), "Return" = table(), "Contexts" = table("_class" = 6), "DeadContext" = table(), "_class" = 5)
        Ctx["Contexts",table]:pushTable(Ctx)
        return Ctx
    }
    
    function table table:cluaCTXPushReturn(Ret:table, Multipe){
        if(!(This["_class",number] == 6)){
            error("cluaCTXPushReturn" + " " + "can't use to:" + " " + "_CLUA_TYPE_CONTEXTS" + "[got " + This["_class",number] + "]" + ":" + 327)
        }
        local CtxCount = This:ncount()
        
        if(!CtxCount){
            error("cluaCTXPushReturn" + " " + "Ctxs count is 0" + ":" + 329)
        }
        local LCtx = This[CtxCount,table]
        
        if(!(LCtx["_class",number] == 5)){
            error("cluaCTXPushReturn" + " " + "LCtx" + " " + "_CLUA_TYPE_CONTEXT" + "[got " + LCtx["_class",number] + "]" + ":" + 330)
        }
        local Scopes = LCtx["Scopes",table]
        
        if(!(Scopes["_class",number] == 9)){
            error("cluaCTXPushReturn" + " " + "Scopes" + " " + "_CLUA_TYPE_SCOPES" + "[got " + Scopes["_class",number] + "]" + ":" + 331)
        }
        local ScopesCount = Scopes:ncount()
        local LScope = Scopes[ScopesCount,table]
        
        if(!(LScope["_class",number] == 8)){
            error("cluaCTXPushReturn" + " " + "LScope not scope" + " " + "_CLUA_TYPE_SCOPE" + "[got " + LScope["_class",number] + "]" + ":" + 334)
        }
        
        if(Multipe){
            foreach(K:number, T:table = Ret){
                if(!(T["_class",number] == 2)){
                    error("cluaCTXPushReturn" + " " + "can't use to:" + " " + "_CLUA_TYPE_VARIABLE" + "[got " + T["_class",number] + "]" + ":" + 339)
                }
            }
            LScope["Return",table] = Ret
        }else{
            if(!(Ret["_class",number] == 2)){
                error("cluaCTXPushReturn" + " " + "can't use to:" + " " + "_CLUA_TYPE_VARIABLE" + "[got " + Ret["_class",number] + "]" + ":" + 344)
            }
            LScope["Return",table]:pushTable(Ret)
        }
        
        if(ScopesCount == 1){
            LCtx["Return",table] = LScope["Return",table]
        }else{
            local LLScope = Scopes[ScopesCount - LScope["IndexReturn",number],table]
            
            if(!(LLScope["_class",number] == 8)){
                error("cluaCTXPushReturn" + " " + "LLScope not scope" + " " + "_CLUA_TYPE_SCOPE" + "[got " + LLScope["_class",number] + "]" + ":" + 352)
            }
            LLScope["Scopes",table]:pushTable(Scopes:cluaSCOPEpop())
        }
        return This
    }
    
    function number table:cluaContextExecute(Perf){
        if(!(This["_class",number] == 5)){
            error("cluaContextExecute" + " " + "can't execute: " + " " + "_CLUA_TYPE_CONTEXT" + "[got " + This["_class",number] + "]" + ":" + 459)
        }
        
        if(This["IsComplete",number]){
            return 1
        }
        local Contexts = This["Contexts",table]
        local Instance = This["Instance",table]
        local GVars = Instance["Vars",table]
        
        while(perf(Perf)){
            local ContextsCount = Contexts:ncount()
            local Context = Contexts[ContextsCount,table]
            local Scopes = Context["Scopes",table]
            local ScopesCount = Scopes:ncount()
            local LScope = Scopes[ScopesCount,table]
            local SVars = LScope["Vars",table]
            local Code = LScope["Code",table]
            local Type = Code["_Type",number]
            local I = LScope["Instruction",number]
            
            switch(Type){
                case 10,
                    if(Code:ncount() + 1 == I){
                        Scopes:cluaSCOPEpop()
                        break
                    }
                    local Statment = Code[I,table]
                    Scopes:cluaSCOPEpush(Statment, 1)
                    break
                case 23,
                    local Ctx = Code[1,table]
                    
                    if(I == 1){
                        Contexts:pushTable(Ctx)
                        break
                    }
                    local DeadContext = Context["DeadContext",table]
                    Contexts:cluaCTXPushReturn(DeadContext["Return",table], 1)
                    break
                case 1,
                    local VarArg = Context["VarArg",table]
                    local E2Func = Code[1,string]
                    local Rets = (E2Func)(Instance, VarArg)[table]
                    Contexts:cluaCTXPushReturn(Rets, 1)
                    break
                case 2,
                    local Args = Code[2,table]
                    local ArgsCount = Args:ncount() + 1
                    local I = ArgsCount - I
                    
                    if(I >= 1){
                        local Statment = Args[I,table]
                        Scopes:cluaSCOPEpush(Statment, 1)
                    }elseif(I == 0){
                        local Statment = Code[I + 1,table]
                        Scopes:cluaSCOPEpush(Statment, 1)
                    }elseif(I == -1){
                        local LScopes = LScope["Scopes",table]
                        local LScopesCount = LScopes:ncount()
                        local Callee = LScopes[LScopesCount,table]["Return",table][1,table]
                        local CalleeType = Callee["Type",number]
                        
                        if(CalleeType == 2){
                            LScopes[LScopesCount,table] = Callee
                        }elseif(CalleeType == 7){
                            error("Not implement (check __call metamethod)")
                        }else{
                            error("attempt to call a " + CalleeType + " value")
                        }
                    }elseif(I + 1 >= (ArgsCount - 2) * -1){
                        local LScopes = LScope["Scopes",table]
                        local Callee = LScopes[LScopes:ncount(),table]
                        local Index = (I + 1) * -1
                        local Args = Callee["Value",table]["Args",table]
                        local Ctx = Callee["NewCtx",table]
                        local Vars = Ctx["Scopes",table][1,table]["Vars",table]
                        local Arg = LScopes[Index,table]["Return",table][1,table]
                        
                        if(Args:exists(Index)){
                            Vars[Args[Index,string],table] = Arg
                        }
                        Ctx["VarArg",table]:pushTable(Arg)
                    }elseif(I + 1 >= (ArgsCount - 1) * -1){
                        local LScopes = LScope["Scopes",table]
                        local Callee = LScopes[LScopes:ncount(),table]
                        local Index = (I + 1) * -1
                        local Args = Callee["Value",table]["Args",table]
                        local Ctx = Callee["NewCtx",table]
                        local Vars = Ctx["Scopes",table][1,table]["Vars",table]
                        local Arg = LScopes[Index,table]["Return",table]
                        local VarArg = Ctx["VarArg",table]
                        local ArgCount = Arg:ncount()
                        
                        for(I=1, ArgCount){
                            if(Args:exists(Index + I - 1)){
                                Vars[Args[Index + I - 1,string],table] = Arg[I,table]
                            }
                            VarArg:pushTable(Arg[I,table])
                        }
                    }else{
                        local LScopes = LScope["Scopes",table]
                        local Callee = LScopes[LScopes:ncount(),table]
                        local CalleeType = Callee["Type",number]
                        
                        if(CalleeType == 2){
                            Scopes:cluaSCOPEpop()
                            Scopes:cluaSCOPEpush(table("_Type" = 23, 1 = Callee["NewCtx",table]), 1)
                        }elseif(CalleeType == 7){
                            error("Not implement (check __call metamethod)")
                        }else{
                            print(format("%p", LScopes))
                            error("attempt to call a " + CalleeType + " value")
                        }
                    }
                    break
                case 17,
                    local VarType = Code[1,number]
                    local Variable = Instance:cluaNewVar(VarType)
                    
                    switch(VarType){
                        case 5,
                        case 3,
                            Variable["Value",number] = Code[2,number]
                            break
                        case 4,
                            Variable["Value",string] = Code[2,string]
                            break
                        case 8,
                            break
                        default,
                            error("VarType Type is not defined: " + VarType)
                    }
                    Contexts:cluaCTXPushReturn(Variable, 0)
                    break
                case 15,
                    local I = ScopesCount - I
                    local Name = Code[1,string]
                    local Variable = table()
                    
                    if(I != 0){
                        local SVars = Scopes[I,table]["Vars",table]
                        
                        if(SVars:exists(Name)){
                            Variable = SVars[Name,table]
                        }
                    }elseif(GVars:exists(Name)){
                        Variable = GVars[Name,table]
                    }else{
                        I = -1
                    }
                    
                    if(I != -1){
                        if(Variable["_class",number] == 2){
                            if(Variable["Type",number] == 2){
                                Variable["NewCtx",table] = Variable["Value",table]:cluaCreateFuncContext()
                            }
                            Contexts:cluaCTXPushReturn(Variable, 0)
                        }
                    }else{
                        Contexts:cluaCTXPushReturn(Instance:cluaNewVar(8), 0)
                    }
                    break
                case 21,
                    if(I == 1){
                        local Left = Code[2,table]
                        local Right = Code[3,table]
                        Scopes:cluaSCOPEpush(Left, 1)
                        Scopes:cluaSCOPEpush(Right, 2)
                    }else{
                        local LScopes = LScope["Scopes",table]
                        local LScopesCount = LScopes:ncount()
                        local Left = LScopes[LScopesCount - 0,table]["Return",table][1,table]
                        local Right = LScopes[LScopesCount - 1,table]["Return",table][1,table]
                        local Operator = Code[1,number]
                        local Ret = Instance:cluaNewVar(8)
                        
                        if(!(Right["_class",number] == 2)){
                            error("cluaContextExecute" + " " + "isnt Variable" + " " + "_CLUA_TYPE_VARIABLE" + "[got " + Right["_class",number] + "]" + ":" + 661)
                        }
                        
                        if(!(Left["_class",number] == 2)){
                            error("cluaContextExecute" + " " + "isnt Variable" + " " + "_CLUA_TYPE_VARIABLE" + "[got " + Left["_class",number] + "]" + ":" + 662)
                        }
                        
                        if(0){

                        }else{
                            if(!(Left["Type",number] == Right["Type",number])){
                                error("Not implement (check " + "cluaContextExecute" + ":" + 667 + ")")
                            }
                            
                            switch(Operator){
                                case 1,
                                    Ret = Instance:cluaNewVar(5)
                                    Ret["Value",number] = Left["Value",number] + Right["Value",number]
                                    break
                                case 2,
                                    Ret = Instance:cluaNewVar(5)
                                    Ret["Value",number] = Left["Value",number] - Right["Value",number]
                                    break
                                case 3,
                                    Ret = Instance:cluaNewVar(5)
                                    Ret["Value",number] = Left["Value",number] * Right["Value",number]
                                    break
                                case 4,
                                    Ret = Instance:cluaNewVar(5)
                                    Ret["Value",number] = Left["Value",number] / Right["Value",number]
                                    break
                                case 7,
                                    Ret = Instance:cluaNewVar(5)
                                    Ret["Value",number] = Left["Value",number] % Right["Value",number]
                                    break
                                case 13,
                                    error("Not implement (check " + "cluaContextExecute" + ":" + 675 + ")")
                                    break
                                case 14,
                                    Ret = Instance:cluaNewVar(3)
                                    Ret["Value",number] = Left["Value",number] < Right["Value",number]
                                    break
                                case 15,
                                    Ret = Instance:cluaNewVar(3)
                                    Ret["Value",number] = Left["Value",number] > Right["Value",number]
                                    break
                                case 16,
                                    Ret = Instance:cluaNewVar(3)
                                    Ret["Value",number] = Left["Value",number] <= Right["Value",number]
                                    break
                                case 17,
                                    Ret = Instance:cluaNewVar(3)
                                    Ret["Value",number] = Left["Value",number] >= Right["Value",number]
                                    break
                                case 18,
                                    Ret = Instance:cluaNewVar(3)
                                    Ret["Value",number] = Left["Value",number] == Right["Value",number]
                                    break
                                case 19,
                                    Ret = Instance:cluaNewVar(3)
                                    Ret["Value",number] = Left["Value",number] != Right["Value",number]
                                    break
                                case 20,
                                    Ret = Instance:cluaNewVar(3)
                                    Ret["Value",number] = Left["Value",number] & Right["Value",number]
                                    break
                                case 21,
                                    Ret = Instance:cluaNewVar(3)
                                    Ret["Value",number] = Left["Value",number] | Right["Value",number]
                                    break
                                default,
                                    error("Not implement (check " + "cluaContextExecute" + ":" + 686 + ")")
                                    break
                            }
                        }
                        Contexts:cluaCTXPushReturn(Ret, 0)
                    }
                    break
                case 20,
                    if(I == 1){
                        local Expr = Code[2,table]
                        Scopes:cluaSCOPEpush(Expr, 1)
                    }else{
                        local LScopes = LScope["Scopes",table]
                        local LScopesCount = LScopes:ncount()
                        local Expr = LScopes[LScopesCount - 0,table]["Return",table][1,table]
                        local Operator = Code[1,number]
                        local Ret = Instance:cluaNewVar(8)
                        
                        if(!(Expr["_class",number] == 2)){
                            error("cluaContextExecute" + " " + "isnt Variable" + " " + "_CLUA_TYPE_VARIABLE" + "[got " + Expr["_class",number] + "]" + ":" + 704)
                        }
                        
                        if(0){

                        }else{
                            switch(Operator){
                                case 1,
                                    Ret = Instance:cluaNewVar(5)
                                    Ret["Value",number] = -Expr["Value",number]
                                    break
                                case 2,
                                    switch(Expr["Type",number]){
                                        case 8,
                                            Ret = Instance:cluaNewVar(3)
                                            Ret["Value",number] = 1
                                            break
                                        case 3,
                                            Ret = Instance:cluaNewVar(3)
                                            Ret["Value",number] = !Expr["Value",number]
                                            break
                                        default,
                                            Ret = Instance:cluaNewVar(3)
                                            Ret["Value",number] = 0
                                            break
                                    }
                                    break
                                case 3,
                                    switch(Expr["Type",number]){
                                        case 4,
                                            Ret = Instance:cluaNewVar(5)
                                            Ret["Value",number] = Expr["Value",string]:length()
                                            break
                                        case 7,
                                            Ret = Instance:cluaNewVar(5)
                                            Ret["Value",number] = Expr["Value",table]:ncount()
                                            break
                                        default,
                                            error("Not implement (check " + "cluaContextExecute" + ":" + 722 + ")")
                                            break
                                    }
                                    break
                                default,
                                    error("Not implement (check " + "cluaContextExecute" + ":" + 726 + ")")
                                    break
                            }
                        }
                        Contexts:cluaCTXPushReturn(Ret, 0)
                    }
                    break
                case 18,
                    local CurrVar = LScope["CurrVar",table]
                    local Code = Code[1,table]
                    
                    if(I == 1){
                        LScope["CurrVar",table] = Instance:cluaNewVar(7)
                    }elseif(I == Code:count() * 2 + 2){
                        Contexts:cluaCTXPushReturn(CurrVar, 0)
                    }elseif(!(I % 2)){
                        local Field = Code[I / 2,table]
                        Scopes:cluaSCOPEpush(Field[2,table], 1)
                        
                        if(!Field[3,number]){
                            Scopes:cluaSCOPEpush(Field[1,table], 2)
                        }
                    }else{
                        local LScopes = LScope["Scopes",table]
                        local LScopesCount = LScopes:ncount()
                        local Value = LScopes[LScopesCount - 0,table]["Return",table][1,table]
                        local Key = LScopes[LScopesCount - 1,table]["Return",table][1,table]
                        local GenKey = Code[(I - 1) / 2,table][3,number]
                        
                        if(GenKey){
                            local Key = CurrVar["_GenKey",number] + 1
                            CurrVar[Key,table] = Value
                            CurrVar["_GenKey",number] = Key
                        }else{
                            local KeyT = Key["Type",number]
                            
                            if(KeyT == 5){
                                CurrVar[Key["Value",number],table] = Value
                            }else{
                                local KeyP = (KeyT == 3 ? Key["Value",number] + "" : (KeyT == 4 ? Key["Value",string] : format("%p", Key["Value",table])))
                                CurrVar[KeyT + ":TYPE-VALUE:" + KeyP,table] = Value
                            }
                        }
                    }
                    break
                case 19,
                    if(I == 1){
                        local Object = Code[1,table]
                        local Member = Code[2,table]
                        Scopes:cluaSCOPEpush(Object, 1)
                        Scopes:cluaSCOPEpush(Member, 2)
                    }else{
                        local LScopes = LScope["Scopes",table]
                        local LScopesCount = LScopes:ncount()
                        local Object = LScopes[LScopesCount - 0,table]["Return",table][1,table]
                        local Member = LScopes[LScopesCount - 1,table]["Return",table][1,table]
                        local Ret = table()
                        local KeyT = Member["Type",number]
                        
                        if(KeyT == 5){
                            Ret = Object[Member["Value",number],table]
                        }else{
                            local KeyP = (KeyT == 3 ? Member["Value",number] + "" : (KeyT == 4 ? Member["Value",string] : format("%p", Member["Value",table])))
                            Ret = Object[KeyT + ":TYPE-VALUE:" + KeyP,table]
                        }
                        
                        if(!Ret["Type",number]){
                            Ret = Instance:cluaNewVar(8)
                        }
                        Contexts:cluaCTXPushReturn(Ret, 0)
                    }
                    break
                default,
                    error("cluaContextExecute undefined type: " + Type)
                    break
            }
            
            if(!Scopes:ncount()){
                Context["DeadContext",table] = Contexts:popTable()
                
                if(!Contexts:ncount()){
                    Context["IsComplete",number] = 1
                    return 1
                }
            }
            LScope["Instruction",number] = I + 1
        }
        return 0
    }
    #include "lua/clua_env"
    
    function table table:cluaFuncExecute(){
        return This:cluaCreateFuncContext()
    }
}

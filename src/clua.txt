@name CLua

#@typedef table clua_instance
#@typedef table clua_variable
#@typedef table clua_func
#@typedef table clua_func_ext

#@typedef table clua_context
#@typedef table clua_contexts
#@typedef table clua_contexts_in_scope

#@typedef table clua_scope
#@typedef table clua_scopes
#@typedef table clua_scopes_in_scope

#[
	@define _assert(CONDITION, MSG) \
		if (!CONDITION) { \
			error(__FUNC__ + " " + MSG + ":" + __LINE__) \
		}
		
	@define _assertExpr(CONDITION, EXPR) \
		if (!CONDITION) { \
			EXPR \
		}
		
		
	@define _assertClass(TABLE, MSG, TYPE) \
		_assert(TABLE["_class",number] == TYPE, MSG + __ENUM__("_CLUA_TYPE_", TYPE) + "[got " + TABLE["_class",number] + "]")
		
	@define _assertSubClass(TABLE, MSG, TYPE) \
		_assert(TABLE["_classsub",number] == TYPE, MSG+ __ENUM__("_CLUA_TYPE_", TYPE) + "[got " + TABLE["_classsub",number] + "]")
		
	@define _assertType(TABLE, MSG, TYPE) \
		_assert(TABLE["_Type",number] == TYPE, MSG)
		
		
	@define _assertNClass(TABLE, MSG, TYPE) \
		_assert(TABLE["_class",number] != TYPE, MSG + __ENUM__("_CLUA_TYPE_", TYPE) + "[got " + TABLE["_class",number] + "]")
		
	@define _assertNSubClass(TABLE, MSG, TYPE) \
		_assert(TABLE["_classsub",number] != TYPE, MSG+ __ENUM__("_CLUA_TYPE_", TYPE) + "[got " + TABLE["_classsub",number] + "]")
		
	@define _assertNType(TABLE, MSG, TYPE) \
		_assert(TABLE["_Type",number] != TYPE, MSG)
		
		
	@define _debug(EXPR) #[@debug]# EXPR
	
	@define _notImp \
		error("Not implement (check " + __FUNC__ + ":" + __LINE__ + ")")
		
	
	@enum _LUA_TYPE_ {
		USERDATA,
		FUNCTION,
		BOOLEAN ,
		STRING  ,
		NUMBER  ,
		THREAD  ,
		TABLE   ,
		NIL     ,
	}
	
	@enum _CLUA_TYPE_ {
		INSTANCE,
		VARIABLE,
		FUNC    ,
		FUNC_EXT,
		
		CONTEXT ,
		CONTEXTS,
		CONTEXTS_IN_SCOPE,
		
		SCOPE ,
		SCOPES,
		SCOPES_IN_SCOPE,
	}
	
	@enum _CLUA_INST_ {
		EXT_CALL   , #statments
		CALL       ,
		DECLARATION,
		ASSIGMENT  ,
		CONTINUE   , #GLUA
		BREAK      ,
		RETURN     ,
		LABEL      ,
		GOTO       ,
		BLOCK      ,
		IF         ,
		FOR        ,
		WHILE      ,
		REPEAT     ,
		
		IDENTIFIER , #expression
		VARARG     ,
		LITERAL    ,
		TABLE      ,
		LOOKUP     ,
		UNARY      ,
		BINARY     ,
		FUNCTION   ,
		
		CTX        , #for internal
	}
	
	@enum _CLUA_BINARY_ {
		ADD  = 1 , #+
		SUB  = 2 , #-
		MUL  = 3 , #*
		DIV  = 4 , #/
			     , #^  - skip
			     , #// - skip
		MOD  = 7 , #%
			     , #&  - skip
			     , #~  - skip
			     , #|  - skip
			     , #>> - skip
			     , #<< - skip
		CNC  = 13, #..
		LS   = 14, #<
		GR   = 15, #>
		EQLS = 16, #<=
		EQGR = 17, #>=
		EQ   = 18, #==
		NEQ  = 19, #~=
		AND  = 20, #and, && - glua
		OR   = 21, #or,  || - glua
	}
	
	@enum _CLUA_UNARY_ {
		NEG  = 1, #-
		NOT  = 2, #not, ! - glua
		SHP  = 3, ##
		        , #~ - skip
	}
]#

if(first()){
	##@inline
	#@ipref lua/
	#include "clua_env"
	
	function table table:cluaNewVar(Type){
		_debug(_assertClass(This, "can't use to", _CLUA_TYPE_INSTANCE))
		
		switch(Type){
			case _LUA_TYPE_USERDATA,
			case _LUA_TYPE_FUNCTION,
			case _LUA_TYPE_BOOLEAN ,
			case _LUA_TYPE_STRING  ,
			case _LUA_TYPE_NUMBER  ,
			case _LUA_TYPE_THREAD  ,
			case _LUA_TYPE_TABLE   ,
			case _LUA_TYPE_NIL     ,
				return table(
					#"Value" = ...,
					"Type" = Type,
					"_class" = _CLUA_TYPE_VARIABLE
				)
			
			default, error("cluaNewVar var type not found: " + Type)
		}
	}
	
	function table table:cluaGetVar(Name:string){ #[ Prototype [Not use very expensive, use stack alternative (identifier)] (DEBUG) ]#
		_debug(_assertClass(This, "can't get var from:", _CLUA_TYPE_CONTEXT))
		
		if(1){ #[ Find from local scopes ]#
			local Scopes = This["Scopes",table]
			local Count = Scopes:ncount()
			
			for(I=Count, 1, -1){
				local SVars = Scopes[I,table]["Vars",table]
				
				if(SVars:exists(Name)){
					return SVars[Name,table]
				}
			}
		}
		
		if(1){
			local Instance = This["Instance",table]
			local GVars = Instance["Vars",table]
			
			if(GVars:exists(Name)){
				return GVars[Name,table]
			}
			
			if(1){
				return Instance:cluaNewVar(_LUA_TYPE_NIL)
			}
		}
	}
	
	function table table:cluaMakeExtFunc(Name:string){
		_debug(_assertClass(This, "can't use to", _CLUA_TYPE_INSTANCE))
		
		local ExtFunc = This:cluaNewVar(_LUA_TYPE_FUNCTION)
		
		ExtFunc["Value",table] = table(
			"Code" = table(
				"_Type" = _CLUA_INST_BLOCK,
				1 = table(
					"_Type" = _CLUA_INST_EXT_CALL,
					1 = "clua_" + Name
				)
			),
			"Instance" = This,
			"Args" = table(), #[ always empty ]#
			"_class" = _CLUA_TYPE_FUNC_EXT
		)
		
		return ExtFunc
	}
	
	function table table:cluaBuildEnv(Vars:table){
		_debug(_assertClass(This, "can't use to", _CLUA_TYPE_INSTANCE))
		_assertClass(Vars, "accept only table variables", _CLUA_TYPE_VARIABLE)
		
		This["Vars",table] = This["Vars",table]:merge(Vars)
		
		return This
	}
	
	
	function table table:cluaBuildEnv(){
		_debug(_assertClass(This, "can't use to", _CLUA_TYPE_INSTANCE))
		
		This["Vars",table] = table(
			"print" = This:cluaMakeExtFunc("print")
		)
		
		return This
	}
	
	function table cluaInstance(){
		local Version = 5.1
		
		return table(
			"Vars" = table(),
			"Version" = Version,
			"_class" = _CLUA_TYPE_INSTANCE
		):cluaBuildEnv()
	}
	
	function table table:cluaToFunc(Code:table){
		_debug(_assertClass(This, "not compile to function (This):", _CLUA_TYPE_INSTANCE))
		_debug(_assertType(Code, "not compile to function (Code)", _CLUA_INST_BLOCK))
		
		return table(
			"Code" = Code,
			"Instance" = This,
			"Args" = table(),
			"_class" = _CLUA_TYPE_FUNC
		)
	}
	
	function table table:cluaSCOPEpushLastScopeInScope(Scope:table){
		_debug(_assertClass(This, "can't use to:", _CLUA_TYPE_SCOPES))
		_debug(_assertNSubClass(This, "the function can only be used inside the scope context:", _CLUA_TYPE_SCOPES_IN_SCOPE))
		
		local LScope = This[This:ncount(),table]
		LScope["Scopes",table]:pushTable(Scope)
		
		return This
	}
	
	function table table:cluaSCOPEpush(Code:table){
		_debug(_assertClass(This, "can't use to:", _CLUA_TYPE_SCOPES))
		_debug(_assert(Code["_Type",number], "Statment type is null"))
		
		This:pushTable(table(
			"Code" = Code,
			"Vars" = table(), #Локальные переменные
			"Scopes" = table( #Сюда попадают мертвые скопы, что бы брать значения, cluaSCOPEpushLastScopeInScope
				"_class" = _CLUA_TYPE_SCOPES,
				"_classsub" = _CLUA_TYPE_SCOPES_IN_SCOPE
			),
			"Contexts" = table(
				"_class" = _CLUA_TYPE_CONTEXTS,
				"_classsub" = _CLUA_TYPE_CONTEXTS_IN_SCOPE
			),
			"Return" = table(), #тут значения которые вернул скоп
			"Instruction" = 1,  #счетчик выполнения скопа
			"_class" = _CLUA_TYPE_SCOPE
		))
		
		return This
	}
	
	function table table:cluaSCOPEpop(){ #Умертвляет скоп и возращает его
		_debug(_assertClass(This, "can't use to:", _CLUA_TYPE_SCOPES))
		
		local Contexts = This["Contexts",table]
		local Context = Contexts[Contexts:ncount(),table]
		local DeadScope = This:popTable()
		
		Context["DeadScope",table] = DeadScope
		
		return DeadScope
	}
	
	function table table:cluaCreateFuncContext(){
		_debug(_assert(
			This["_class",number] == _CLUA_TYPE_FUNC |
			This["_class",number] == _CLUA_TYPE_FUNC_EXT,
			"can't create context"
		))
		
		local Ctx = table(
			"Scopes" = table(
				"_class" = _CLUA_TYPE_SCOPES
			):cluaSCOPEpush(This["Code",table]),
			"Instance" = This["Instance",table],
			"Func" = This,
			"IsComplete" = 0,
			"VarArg" = table(),
			"Return" = table(),
			"Contexts" = table(
				"_class" = _CLUA_TYPE_CONTEXTS
			),
			"DeadScope" = table(),
			"_class" = _CLUA_TYPE_CONTEXT
		)
		
		Ctx["Contexts",table]:pushTable(Ctx)
		
		return Ctx
	}
	
	function table table:cluaSCOPEpushReturn(Ret:table){
		_debug(_assertClass(Ret, "can't use to:", _CLUA_TYPE_VARIABLE))
		
		local LScope = This[This:ncount(),table]
		
		LScope["Return",table]:pushTable(Ret)
		This:cluaSCOPEpushLastScopeInScope(
			This:cluaSCOPEpop()
		)
		
		return This
	}
	
	function table table:cluaSCOPEpushReturns(Rets:table){
		#[@debug]#
		foreach(K:number, T:table = Rets){
			_debug(_assertClass(T, "can't use to:", _CLUA_TYPE_VARIABLE))
		}
		
		local LScope = This[This:ncount(),table]
		
		LScope["Return",table] = Rets
		This:cluaSCOPEpushLastScopeInScope(
			This:cluaSCOPEpop()
		)
		
		return This
	}
	
	#_CLUA_TYPE_CONTEXT - контекст выполнения функции
	#_CLUA_TYPE_CONTEXTS
	#_CLUA_TYPE_SCOPE - выполняет код, содержит локальные переменные, нужен что бы делить выполнение на шаги
	#_CLUA_TYPE_SCOPES - содержит в себе сколько скопов, всегда выполняется последний
	
#[
	@define _LSCOPES \
		local LScopes = LScope["Scopes",table] \
		local LScopesCount = LScopes:ncount()
	
	@define _LSCOPEGetReturn(SCOPEINDEX, INDEX) \
		LScopes[LScopesCount - SCOPEINDEX,table]["Return",table][INDEX,table]
		
	@define _assertVar(VAR) \
		_debug(_assertClass(VAR, "isnt Variable", _CLUA_TYPE_VARIABLE))
		
	@define _VarType(VAR) \
		VAR["Type",number]
		
		
	@define _VarSetStr(VAR, VAL) \
		VAR["Value",string] = VAL
		
	@define _VarSetTbl(VAR, VAL) \
		VAR["Value",table] = VAL
		
	@define _VarSetNum(VAR, VAL) \
		VAR["Value",number] = VAL
		
	@define _VarSetBool(VAR, VAL) \
		VAR["Value",number] = VAL
		
		
	@define _VarStr(VAR) \
		VAR["Value",string]
		
	@define _VarTbl(VAR) \
		VAR["Value",table]
		
	@define _VarNum(VAR) \
		VAR["Value",number]
		
	@define _VarBool(VAR) \
		VAR["Value",number]
		
	
	@define _VarNumOp(RESULT, LEFT, OP, RIGHT) \
		RESULT["Value",number] = __BINARY__(_VarNum(Left), OP, _VarNum(Right))
	
	@define _VarBoolOp(RESULT, LEFT, OP, RIGHT) \
		RESULT["Value",number] = __BINARY__(_VarBool(Left), OP, _VarBool(Right))
	
	
	@define _newVarStr \
		Instance:cluaNewVar(_LUA_TYPE_STRING)
		
	@define _newVarTbl \
		Instance:cluaNewVar(_LUA_TYPE_TABLE)
	
	@define _newVarNum \
		Instance:cluaNewVar(_LUA_TYPE_NUMBER)
		
	@define _newVarBool \
		Instance:cluaNewVar(_LUA_TYPE_BOOLEAN)
		
	@define _newVarNil \
		Instance:cluaNewVar(_LUA_TYPE_NIL)
	
	
	@define _THROW_LUA_ERROR(MSG) \
		_notImp
]#
	function number table:cluaContextExecute(Perf){
		_debug(_assertClass(This, "can't execute: ", _CLUA_TYPE_CONTEXT))
		
		if(This["IsComplete",number]){
			return 1
		}
		
		local Contexts = This["Contexts",table]
		local Instance = This["Instance",table]
		local GVars = Instance["Vars",table]
		
		while(perf(Perf)){
			local ContextsCount = Contexts:ncount()
			local Context = Contexts[ContextsCount,table]
			local Scopes = Context["Scopes",table]
			local ScopesCount = Scopes:ncount()
			local LScope = Scopes[ScopesCount,table]
			local SVars = LScope["Vars",table]
			local Code = LScope["Code",table]
			
			local Type = Code["_Type",number]
			local I = LScope["Instruction",number]
			
			switch(Type){
				case _CLUA_INST_BLOCK,
					if(Code:ncount() + 1 == I){
						Scopes:cluaSCOPEpop()
						break
					}
					
					local Statment = Code[I,table]
					Scopes:cluaSCOPEpush(Statment)
					break
					
				case _CLUA_INST_CTX, #[ Function in function ]#
					local Ctx = Code[1,table]
					
					if(I == 1){
						Contexts:pushTable(Ctx)
						break
					}
					
					local DeadContext = LScope["Contexts",table][1,table]
					local DeadScope = DeadContext["DeadScope",table]
					
					Scopes:cluaSCOPEpushReturns(DeadScope["Return",table])
					break
					
				case _CLUA_INST_EXT_CALL, #[ Call e2 function ]#
					local VarArg = Context["VarArg",table]
					local E2Func = Code[1,string]
					
					local Rets = (E2Func)(Instance, VarArg)[table]
					Scopes:cluaSCOPEpushReturns(Rets)
					break
					
				case _CLUA_INST_CALL, #TODO: обьявить все не понятные возвраты
					local Args = Code[2,table]
					local ArgsCount = Args:ncount() + 1
					local I = ArgsCount - I
					
					if(I >= 1){ #[ Get Args ]#
						local Statment = Args[I,table]
						Scopes:cluaSCOPEpush(Statment)
					}elseif(I == 0){ #[ Get Callee ]#
						local Statment = Code[I + 1,table]
						Scopes:cluaSCOPEpush(Statment)
					}elseif(I == -1){ #[ Callee ]#
						local LScopes = LScope["Scopes",table]
						local LScopesCount = LScopes:ncount()
						local Callee = LScopes[LScopesCount,table]["Return",table][1,table]
						local CalleeType = Callee["Type",number]
						
						if(CalleeType == _LUA_TYPE_FUNCTION){
							LScopes[LScopesCount,table] = Callee
						}elseif(CalleeType == _LUA_TYPE_TABLE){
							error("Not implement (check __call metamethod)") #TODO: 
						}else{
							error("attempt to call a " + CalleeType + " value")
						}
					}elseif((I + 1) >= (ArgsCount - 2) * -1){ #[ Args ]#
						local LScopes = LScope["Scopes",table]
						local Callee = LScopes[LScopes:ncount(),table]
						
						local Index = (I + 1) * -1
						local Args = Callee["Value",table]["Args",table]
						local Ctx = Callee["NewCtx",table]
						local Vars = Ctx["Scopes",table][1,table]["Vars",table]
						local Arg = LScopes[Index,table]["Return",table][1,table]
						
						if(Args:exists(Index)){
							Vars[Args[Index,string],table] = Arg
						}
						
						Ctx["VarArg",table]:pushTable(Arg)
					}elseif((I + 1) >= (ArgsCount - 1) * -1){ #[ VarArg ]#
						local LScopes = LScope["Scopes",table]
						local Callee = LScopes[LScopes:ncount(),table]
						
						local Index = (I + 1) * -1
						local Args = Callee["Value",table]["Args",table]
						local Ctx = Callee["NewCtx",table]
						local Vars = Ctx["Scopes",table][1,table]["Vars",table]
						local Arg = LScopes[Index,table]["Return",table]
						local VarArg = Ctx["VarArg",table]
						local ArgCount = Arg:ncount()
						
						for(I=1, ArgCount){ #[ TODO: optimaze (recurent) this for, (return 1,2,...) consumes more ops ]#
							if(Args:exists(Index + I - 1)){
								Vars[Args[Index + I - 1,string],table] = Arg[I,table]
							}
							
							VarArg:pushTable(Arg[I,table])
						}
					}else{
						local LScopes = LScope["Scopes",table]
						local Callee = LScopes[LScopes:ncount(),table]
						local CalleeType = Callee["Type",number]
						
						if(CalleeType == _LUA_TYPE_FUNCTION){
							Scopes:cluaSCOPEpop()
							Scopes:cluaSCOPEpush(
								table(
									"_Type" = _CLUA_INST_CTX,
									1 = Callee["NewCtx",table]
								)
							)
						}elseif(CalleeType == _LUA_TYPE_TABLE){
							error("Not implement (check __call metamethod)") #TODO: 
						}else{
							print(format("%p", LScopes))
							error("attempt to call a " + CalleeType + " value")
						}
					}
					break
					
				case _CLUA_INST_LITERAL,
					local VarType = Code[1,number]
					local Variable = Instance:cluaNewVar(VarType)
					
					switch(VarType){
						case _LUA_TYPE_NUMBER,
						case _LUA_TYPE_BOOLEAN,
							Variable["Value",number] = Code[2,number]
							break
						
						case _LUA_TYPE_STRING,
							Variable["Value",string] = Code[2,string]
							break
							
						case _LUA_TYPE_NIL, break
						default, error("VarType Type in not defined: " + VarType)
					}
					
					Scopes:cluaSCOPEpushReturn(Variable)
					break
					
				case _CLUA_INST_IDENTIFIER,
					local I = ScopesCount - I
					local Name = Code[1,string]
					local Variable = table()
					
					if(I != 0){
						local SVars = Scopes[I,table]["Vars",table]
						
						if(SVars:exists(Name)){
							Variable = SVars[Name,table]
						}
					}else{
						if(GVars:exists(Name)){
							Variable = GVars[Name,table]
						}else{
							I = -1
						}
					}
					
					if(I != -1){
						if(Variable["_class",number] == _CLUA_TYPE_VARIABLE){
							if(Variable["Type",number] == _LUA_TYPE_FUNCTION){
								Variable["NewCtx",table] = Variable["Value",table]:cluaCreateFuncContext()
							}
							
							Scopes:cluaSCOPEpushReturn(Variable)
						}
					}else{
						Scopes:cluaSCOPEpushReturn(
							Instance:cluaNewVar(_LUA_TYPE_NIL)
						)
					}
					break
					
				case _CLUA_INST_BINARY,
					if(I == 1){
						local Left = Code[2,table]
						
						Scopes:cluaSCOPEpush(Left)
					}elseif(I == 2){
						local Right = Code[3,table]
						
						Scopes:cluaSCOPEpush(Right)
					}else{            _LSCOPES
						local Right = _LSCOPEGetReturn(0, 1)
						local Left  = _LSCOPEGetReturn(1, 1)
						local Operator = Code[1,number]
						local Ret = _newVarNil
						
						_assertVar(Right)
						_assertVar(Left)
						
						if(0){ #TODO: find meta methods, первый левый, если нету, правый, иначе ошибка
							
						}else{ #default methods
							_assertExpr(_VarType(Left) == _VarType(Right), _THROW_LUA_ERROR("attempt to compare {Type_ARG1} with {Type_ARG2}"))
							
							switch(Operator){
								case _CLUA_BINARY_ADD,  Ret = _newVarNum _VarNumOp(Ret, Left, "+", Right) break
								case _CLUA_BINARY_SUB,  Ret = _newVarNum _VarNumOp(Ret, Left, "-", Right) break
								case _CLUA_BINARY_MUL,  Ret = _newVarNum _VarNumOp(Ret, Left, "*", Right) break
								case _CLUA_BINARY_DIV,  Ret = _newVarNum _VarNumOp(Ret, Left, "/", Right) break
								case _CLUA_BINARY_MOD,  Ret = _newVarNum _VarNumOp(Ret, Left, "%", Right) break
								case _CLUA_BINARY_CNC,  _notImp() break
								
								case _CLUA_BINARY_LS,   Ret = _newVarBool _VarNumOp(Ret, Left, "<" , Right) break
								case _CLUA_BINARY_GR,   Ret = _newVarBool _VarNumOp(Ret, Left, ">" , Right) break
								case _CLUA_BINARY_EQLS, Ret = _newVarBool _VarNumOp(Ret, Left, ">=", Right) break
								case _CLUA_BINARY_EQGR, Ret = _newVarBool _VarNumOp(Ret, Left, "<=", Right) break
								case _CLUA_BINARY_EQ,   Ret = _newVarBool _VarNumOp(Ret, Left, "==", Right) break
								case _CLUA_BINARY_NEQ,  Ret = _newVarBool _VarNumOp(Ret, Left, "!=", Right) break
								case _CLUA_BINARY_AND,  Ret = _newVarBool _VarNumOp(Ret, Left, "&" , Right) break
								case _CLUA_BINARY_OR,   Ret = _newVarBool _VarNumOp(Ret, Left, "|" , Right) break
								
								default, _notImp() break
							}
						}
						
						Scopes:cluaSCOPEpushReturn(Ret)
					}
					break
					
				case _CLUA_INST_UNARY,
					if(I == 1){
						local Expr = Code[2,table]
						
						Scopes:cluaSCOPEpush(Expr)
					}else{            _LSCOPES
						local Expr  = _LSCOPEGetReturn(0, 1)
						local Operator = Code[1,number]
						local Ret = _newVarNil
						
						_assertVar(Expr)
						
						if(0){ #TODO: find meta methods
							
						}else{ #default methods
							switch(Operator){
								case _CLUA_UNARY_NEG,  Ret = _newVarNum _VarSetNum(Ret, -_VarNum(Expr)) break
								case _CLUA_UNARY_NOT,
									switch(_VarType(Expr)){
										case _LUA_TYPE_NIL,     Ret = _newVarBool _VarSetBool(Ret, 1)               break
										case _LUA_TYPE_BOOLEAN, Ret = _newVarBool _VarSetBool(Ret, !_VarBool(Expr)) break
										default,                Ret = _newVarBool _VarSetBool(Ret, 0)               break
									}
									break
								case _CLUA_UNARY_SHP,
									switch(_VarType(Expr)){
										case _LUA_TYPE_STRING, Ret = _newVarNum  _VarSetNum(Ret, _VarStr(Expr):length()) break
										case _LUA_TYPE_TABLE,  Ret = _newVarNum  _VarSetNum(Ret, _VarTbl(Expr):count())  break
										default, _THROW_LUA_ERROR("operator '#' not apply to" + _VarType(Expr))          break
									}
									break
								
								default, _notImp() break
							}
						}
						
						Scopes:cluaSCOPEpushReturn(Ret)
					}
					break
					
				default,
					error("cluaContextExecute undefined type: " + Type)
					break
			}
			
			if(!Scopes:ncount()){
				Context["IsComplete",number] = 1
				LScope["Contexts",table]:pushTable(
					Contexts:popTable()
				)
				
				if(This["IsComplete",number]){
					return 1
				}
			}
			
			LScope["Instruction",number] = I + 1
		}
		
		return 0
	}
	
	function table table:cluaFuncExecute(){
		return This:cluaCreateFuncContext()
	}
}

#[ block	1 ]#
#[ call	2 ]#
#[ identifier	3 ]#
#[ call	4 ]#
@name CLua

#@typedef table clua_instance
#@typedef table clua_variable
#@typedef table clua_func
#@typedef table clua_func_ext

#@typedef table clua_context
#@typedef table clua_contexts
#@typedef table clua_contexts_in_scope

#@typedef table clua_scope
#@typedef table clua_scopes
#@typedef table clua_scopes_in_scope

#[
	@define _assert(CONDITION, MSG) \
		if (!CONDITION) { \
			error(__FUNC__ + " " + MSG) \
		}
		
	@define _assertClass(T, MSG, TYPE) \
		_assert(T["_class",number] == TYPE, MSG + __ENUM__("_CLUA_TYPE_", TYPE))
		
	@define _assertSubClass(T, MSG, TYPE) \
		_assert(T["_subclass",number] == TYPE, MSG) #TODO: subclass #+ __ENUM__("_CLUA_TYPE_", TYPE)
		
	@define _assertType(T, MSG, TYPE) \
		_assert(T["_Type",number] == TYPE, MSG)
		
	@define _debug(EXPR) #[@debug]# EXPR
		
	
	
	
	@enum _LUA_TYPE_ {
		USERDATA,
		FUNCTION,
		BOOLEAN ,
		STRING  ,
		NUMBER  ,
		THREAD  ,
		TABLE   ,
		NIL     ,
	}
	
	@enum _CLUA_TYPE_ {
		INSTANCE,
		VARIABLE,
		FUNC    ,
		FUNC_EXT,
		
		CONTEXT ,
		CONTEXTS,
		CONTEXTS_IN_SCOPE,
		
		SCOPE ,
		SCOPES,
		SCOPES_IN_SCOPE,
	}
	
	@enum _CLUA_INST_ {
		EXT_CALL   , #statments
		CALL       ,
		DECLARATION,
		ASSIGMENT  ,
		CONTINUE   , #GLUA
		BREAK      ,
		RETURN     ,
		LABEL      ,
		GOTO       ,
		BLOCK      ,
		IF         ,
		FOR        ,
		WHILE      ,
		REPEAT     ,
		
		IDENTIFIER , #expression
		VARARG     ,
		LITERAL    ,
		TABLE      ,
		LOOKUP     ,
		UNARY      ,
		BINARY     ,
		FUNCTION   ,
		
		CTX        , #for internal
	}
]#

if(first()){
	##@inline
	#@ipref lua/
	#include "clua_env"
	
	function table table:cluaNewVar(Type){
		_debug(_assertClass(This, "can't use to", _CLUA_TYPE_INSTANCE))
		
		switch(Type){
			case _LUA_TYPE_USERDATA, # "userdata",
			case _LUA_TYPE_FUNCTION, # "function",
			case _LUA_TYPE_BOOLEAN , # "boolean",
			case _LUA_TYPE_STRING  , # "string",
			case _LUA_TYPE_NUMBER  , # "number",
			case _LUA_TYPE_THREAD  , # "thread",
			case _LUA_TYPE_TABLE   , # "table",
			case _LUA_TYPE_NIL     , # "nil",
				return table(
					#"Value" = ...,
					"Type" = Type,
					"_class" = _CLUA_TYPE_VARIABLE
				)
			
			default, error("cluaNewVar var type not found: " + Type)
		}
	}
	
	function table table:cluaGetVar(Name:string){ #[ Prototype [Not use very expensive, use stack alternative (identifier)] (DEBUG) ]#
		_debug(_assertClass(This, "can't get var from:", _CLUA_TYPE_CONTEXT))
		
		if(1){ #[ Find from local scopes ]#
			local Scopes = This["Scopes",table]
			local Count = Scopes:ncount()
			
			for(I=Count, 1, -1){
				local SVars = Scopes[I,table]["Vars",table]
				
				if(SVars:exists(Name)){
					return SVars[Name,table]
				}
			}
		}
		
		if(1){
			local Instance = This["Instance",table]
			local GVars = Instance["Vars",table]
			
			if(GVars:exists(Name)){
				return GVars[Name,table]
			}
			
			if(1){
				return Instance:cluaNewVar(_LUA_TYPE_NIL)
			}
		}
	}
	
	function table table:cluaMakeExtFunc(Name:string){
		_debug(_assertClass(This, "can't use to", _CLUA_TYPE_INSTANCE))
		
		local ExtFunc = This:cluaNewVar(_LUA_TYPE_FUNCTION)
		
		ExtFunc["Value",table] = table(
			"Code" = table(
				"_Type" = _CLUA_INST_BLOCK,
				1 = table(
					"_Type" = _CLUA_INST_EXT_CALL,
					1 = "clua_" + Name
				)
			),
			"Instance" = This,
			"Args" = table(), #[ always empty ]#
			"_class" = _CLUA_TYPE_FUNC_EXT
		)
		
		return ExtFunc
	}
	
	function table table:cluaBuildEnv(Vars:table){
		_debug(_assertClass(This, "can't use to", _CLUA_TYPE_INSTANCE))
		_assertClass(Vars, "accept only table variables", _CLUA_TYPE_VARIABLE)
		
		This["Vars",table] = This["Vars",table]:merge(Vars)
		
		return This
	}
	
	
	function table table:cluaBuildEnv(){
		_debug(_assertClass(This, "can't use to", _CLUA_TYPE_INSTANCE))
		
		This["Vars",table] = table(
			"print" = This:cluaMakeExtFunc("print")
		)
		
		return This
	}
	
	function table cluaInstance(){
		local Version = 5.1
		
		return table(
			"Vars" = table(),
			"Version" = Version,
			"_class" = _CLUA_TYPE_INSTANCE
		):cluaBuildEnv()
	}
	
	function table table:cluaToFunc(Code:table){
		_debug(_assertClass(This, "not compile to function (This):", _CLUA_TYPE_INSTANCE))
		_debug(_assertType(Code, "not compile to function (Code)", _CLUA_INST_BLOCK))
		
		return table(
			"Code" = Code,
			"Instance" = This,
			"Args" = table(),
			"_class" = _CLUA_TYPE_FUNC
		)
	}
	
	function table table:cluaSCOPEpushLastScopeInScope(Scope:table){
		_debug(_assertClass(This, "can't use to:", _CLUA_TYPE_SCOPES))
		_debug(_assertSubClass(This, "the function can only be used inside the scope context:", _CLUA_TYPE_SCOPES_IN_SCOPE))
		
		local LScope = This[This:ncount(),table]
		LScope["Scopes",table]:pushTable(Scope)
		
		return This
	}
	
	function table table:cluaSCOPEpush(Code:table){
		_debug(_assertClass(This, "can't use to:", _CLUA_TYPE_SCOPES))
		_debug(_assert(Code["_Type",string], "Statment type is null"))
		
		This:pushTable(table(
			"Code" = Code,
			"Vars" = table(),
			"Scopes" = table(
				"_class" = _CLUA_TYPE_SCOPES,
				"_classsub" = _CLUA_TYPE_SCOPES_IN_SCOPE
			),
			"Contexts" = table(
				"_class" = _CLUA_TYPE_CONTEXTS,
				"_classsub" = _CLUA_TYPE_CONTEXTS_IN_SCOPE
			),
			"Return" = table(),
			"Instruction" = 1,
			"_class" = _CLUA_TYPE_SCOPE
		))
		
		return This
	}
	
	function table table:cluaSCOPEpop(){
		local Contexts = This["Contexts",table]
		local Context = Contexts[Contexts:ncount(),table]
		local DeadScope = This:popTable()
		
		Context["DeadScope",table] = DeadScope
		
		return DeadScope
	}
	
	function table table:cluaCreateFuncContext(){
		_debug(_assert(
			This["_class",number] == _CLUA_TYPE_FUNC |
			This["_class",number] == _CLUA_TYPE_FUNC_EXT,
			"can't create context"
		))
		
		local Ctx = table(
			"Scopes" = table(
				"_class" = _CLUA_TYPE_SCOPES
			):cluaSCOPEpush(This["Code",table]),
			"Instance" = This["Instance",table],
			"Func" = This,
			"IsComplete" = 0,
			"VarArg" = table(),
			"Return" = table(),
			"Contexts" = table(
				"_class" = _CLUA_TYPE_CONTEXTS
			),
			"DeadScope" = table(),
			"_class" = _CLUA_TYPE_CONTEXT
		)
		
		Ctx["Contexts",table]:pushTable(Ctx)
		
		return Ctx
	}
	
	function table table:cluaSCOPEpushReturn(Ret:table){
		local LScope = This[This:ncount(),table]
		
		LScope["Return",table]:pushTable(Ret)
		This:cluaSCOPEpushLastScopeInScope(
			This:cluaSCOPEpop()
		)
		
		return This
	}
	
	function table table:cluaSCOPEpushReturns(Rets:table){
		local LScope = This[This:ncount(),table]
		
		LScope["Return",table] = Rets
		This:cluaSCOPEpushLastScopeInScope(
			This:cluaSCOPEpop()
		)
		
		return This
	}
	
	function number table:cluaContextExecute(Perf){
		_debug(_assertClass(This, "can't execute: ", _CLUA_TYPE_CONTEXT))
		
		if(This["IsComplete",number]){
			return 1
		}
		
		local Contexts = This["Contexts",table]
		local Instance = This["Instance",table]
		local GVars = Instance["Vars",table]
		
		while(perf(Perf)){
			local ContextsCount = Contexts:ncount()
			local Context = Contexts[ContextsCount,table]
			local Scopes = Context["Scopes",table]
			local ScopesCount = Scopes:ncount()
			local LScope = Scopes[ScopesCount,table]
			local SVars = LScope["Vars",table]
			local Code = LScope["Code",table]
			
			local Type = Code["_Type",number]
			local I = LScope["Instruction",number]
			
			switch(Type){
				case _CLUA_INST_BLOCK,
					if(Code:ncount() + 1 == I){
						Scopes:cluaSCOPEpop()
						break
					}
					
					local Statment = Code[I,table]
					Scopes:cluaSCOPEpush(Statment)
					break
					
				case _CLUA_INST_CTX, #[ Function in function ]#
					local Ctx = Code[1,table]
					
					if(I == 1){
						Contexts:pushTable(Ctx)
						break
					}
					
					local DeadContext = LScope["Contexts",table][1,table]
					local DeadScope = DeadContext["DeadScope",table]
					
					Scopes:cluaSCOPEpushReturns(DeadScope["Return",table])
					break
					
				case _CLUA_INST_EXT_CALL, #[ Call e2 function ]#
					local VarArg = Context["VarArg",table]
					local E2Func = Code[1,string]
					
					local Rets = (E2Func)(Instance, VarArg)[table]
					Scopes:cluaSCOPEpushReturns(Rets)
					break
					
				case _CLUA_INST_CALL, "call", #TODO: обьявить все не понятные возвраты
					local Args = Code[2,table]
					local ArgsCount = Args:ncount() + 1
					local I = ArgsCount - I
					
					if(I == 0){
						local Statment = Code[I + 1,table]
						Scopes:cluaSCOPEpush(Statment)
					}elseif(I >= 1){
						local Statment = Args[I,table]
						Scopes:cluaSCOPEpush(Statment)
					}elseif(I == -1){ #[ Callee ]#
						local LScopes = LScope["Scopes",table]
						local LScopesCount = LScopes:ncount()
						local Callee = LScopes[LScopesCount,table]["Return",table][1,table]
						local CalleeType = Callee["Type",number]
						
						if(CalleeType == _LUA_TYPE_FUNCTION){
							LScopes[LScopesCount,table] = Callee
						}elseif(CalleeType == _LUA_TYPE_TABLE){
							error("Not implement (check __call metamethod)") #TODO: 
						}else{
							error("attempt to call a " + CalleeType + " value")
						}
					}elseif((I + 1) >= (ArgsCount - 2) * -1){ #[ Args ]#
						local LScopes = LScope["Scopes",table]
						local Callee = LScopes[LScopes:ncount(),table]
						
						local Index = (I + 1) * -1
						local Args = Callee["Value",table]["Args",table]
						local Ctx = Callee["NewCtx",table]
						local Vars = Ctx["Scopes",table][1,table]["Vars",table]
						local Arg = LScopes[Index,table]["Return",table][1,table]
						
						if(Args:exists(Index)){
							Vars[Args[Index,string],table] = Arg
						}
						
						Ctx["VarArg",table]:pushTable(Arg)
					}elseif((I + 1) >= (ArgsCount - 1) * -1){ #[ VarArg ]#
						local LScopes = LScope["Scopes",table]
						local Callee = LScopes[LScopes:ncount(),table]
						
						local Index = (I + 1) * -1
						local Args = Callee["Value",table]["Args",table]
						local Ctx = Callee["NewCtx",table]
						local Vars = Ctx["Scopes",table][1,table]["Vars",table]
						local Arg = LScopes[Index,table]["Return",table]
						local VarArg = Ctx["VarArg",table]
						local ArgCount = Arg:ncount()
						
						for(I=1, ArgCount){ #[ TODO: optimaze (recurent) this for, (return 1,2,...) consumes more ops ]#
							if(Args:exists(Index + I - 1)){
								Vars[Args[Index + I - 1,string],table] = Arg[I,table]
							}
							
							VarArg:pushTable(Arg[I,table])
						}
					}else{
						local LScopes = LScope["Scopes",table]
						local Callee = LScopes[LScopes:ncount(),table]
						local CalleeType = Callee["Type",number]
						
						if(CalleeType == _LUA_TYPE_FUNCTION){
							Scopes:cluaSCOPEpop()
							Scopes:cluaSCOPEpush(
								table(
									"_Type" = _CLUA_INST_CTX,
									1 = Callee["NewCtx",table]
								)
							)
						}elseif(CalleeType == _LUA_TYPE_TABLE){
							error("Not implement (check __call metamethod)") #TODO: 
						}else{
							print(format("%p", LScopes))
							error("attempt to call a " + CalleeType + " value")
						}
					}
					break
					
				case _CLUA_INST_LITERAL,
					local VarType = Code[1,number]
					local Variable = Instance:cluaNewVar(VarType)
					
					switch(VarType){
						case _LUA_TYPE_NUMBER,
						case _LUA_TYPE_BOOLEAN,
							Variable["Value",number] = Code[2,number]
							break
						
						case _LUA_TYPE_STRING,
							Variable["Value",string] = Code[2,string]
							break
							
						case _LUA_TYPE_NIL, break
						default, error("VarType Type in not defined: " + VarType)
					}
					
					Scopes:cluaSCOPEpushReturn(Variable)
					break
					
				case _CLUA_INST_IDENTIFIER,
					local I = ScopesCount - I
					local Name = Code[1,string]
					local Variable = table()
					
					if(I != 0){
						local SVars = Scopes[I,table]["Vars",table]
						
						if(SVars:exists(Name)){
							Variable = SVars[Name,table]
						}
					}else{
						if(GVars:exists(Name)){
							Variable = GVars[Name,table]
						}else{
							I = -1
						}
					}
					
					if(I != -1){
						if(Variable["_class",number] == _CLUA_TYPE_VARIABLE){
							if(Variable["Type",number] == _LUA_TYPE_FUNCTION){
								Variable["NewCtx",table] = Variable["Value",table]:cluaCreateFuncContext()
							}
							
							Scopes:cluaSCOPEpushReturn(Variable)
						}
					}else{
						Scopes:cluaSCOPEpushReturn(
							Instance:cluaNewVar(_LUA_TYPE_NIL)
						)
					}
					break
					
				case _CLUA_INST_BINARY,
					
					break
					
				default,
					error("cluaContextExecute undefined type: " + Type)
					break
			}
			
			if(!Scopes:ncount()){
				Context["IsComplete",number] = 1
				LScope["Contexts",table]:pushTable(
					Contexts:popTable()
				)
				
				if(This["IsComplete",number]){
					return 1
				}
			}
			
			LScope["Instruction",number] = I + 1
		}
		
		return 0
	}
	
	function table table:cluaFuncExecute(){
		return This:cluaCreateFuncContext()
	}
}

#[ block	1 ]#
#[ call	2 ]#
#[ identifier	3 ]#
#[ call	4 ]#